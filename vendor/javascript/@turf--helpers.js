var e=6371008.8;var r={centimeters:e*100,centimetres:e*100,degrees:360/(2*Math.PI),feet:e*3.28084,inches:e*39.37,kilometers:e/1e3,kilometres:e/1e3,meters:e,metres:e,miles:e/1609.344,millimeters:e*1e3,millimetres:e*1e3,nauticalmiles:e/1852,radians:1,yards:e*1.0936};var t={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,nauticalmiles:2.9155334959812285e-7,millimeters:1e6,millimetres:1e6,yards:1.195990046};function feature(e,r,t={}){const n={type:"Feature"};(t.id===0||t.id)&&(n.id=t.id);t.bbox&&(n.bbox=t.bbox);n.properties=r||{};n.geometry=e;return n}function geometry(e,r,t={}){switch(e){case"Point":return point(r).geometry;case"LineString":return lineString(r).geometry;case"Polygon":return polygon(r).geometry;case"MultiPoint":return multiPoint(r).geometry;case"MultiLineString":return multiLineString(r).geometry;case"MultiPolygon":return multiPolygon(r).geometry;default:throw new Error(e+" is invalid")}}function point(e,r,t={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!isNumber(e[0])||!isNumber(e[1]))throw new Error("coordinates must contain numbers");const n={type:"Point",coordinates:e};return feature(n,r,t)}function points(e,r,t={}){return featureCollection(e.map((e=>point(e,r))),t)}function polygon(e,r,t={}){for(const r of e){if(r.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(r[r.length-1].length!==r[0].length)throw new Error("First and last Position are not equivalent.");for(let e=0;e<r[r.length-1].length;e++)if(r[r.length-1][e]!==r[0][e])throw new Error("First and last Position are not equivalent.")}const n={type:"Polygon",coordinates:e};return feature(n,r,t)}function polygons(e,r,t={}){return featureCollection(e.map((e=>polygon(e,r))),t)}function lineString(e,r,t={}){if(e.length<2)throw new Error("coordinates must be an array of two or more positions");const n={type:"LineString",coordinates:e};return feature(n,r,t)}function lineStrings(e,r,t={}){return featureCollection(e.map((e=>lineString(e,r))),t)}function featureCollection(e,r={}){const t={type:"FeatureCollection"};r.id&&(t.id=r.id);r.bbox&&(t.bbox=r.bbox);t.features=e;return t}function multiLineString(e,r,t={}){const n={type:"MultiLineString",coordinates:e};return feature(n,r,t)}function multiPoint(e,r,t={}){const n={type:"MultiPoint",coordinates:e};return feature(n,r,t)}function multiPolygon(e,r,t={}){const n={type:"MultiPolygon",coordinates:e};return feature(n,r,t)}function geometryCollection(e,r,t={}){const n={type:"GeometryCollection",geometries:e};return feature(n,r,t)}function round(e,r=0){if(r&&!(r>=0))throw new Error("precision must be a positive number");const t=Math.pow(10,r||0);return Math.round(e*t)/t}function radiansToLength(e,t="kilometers"){const n=r[t];if(!n)throw new Error(t+" units is invalid");return e*n}function lengthToRadians(e,t="kilometers"){const n=r[t];if(!n)throw new Error(t+" units is invalid");return e/n}function lengthToDegrees(e,r){return radiansToDegrees(lengthToRadians(e,r))}function bearingToAzimuth(e){let r=e%360;r<0&&(r+=360);return r}function azimuthToBearing(e){e%=360;return e>180?e-360:e<-180?e+360:e}function radiansToDegrees(e){const r=e%(2*Math.PI);return r*180/Math.PI}function degreesToRadians(e){const r=e%360;return r*Math.PI/180}function convertLength(e,r="kilometers",t="kilometers"){if(!(e>=0))throw new Error("length must be a positive number");return radiansToLength(lengthToRadians(e,r),t)}function convertArea(e,r="meters",n="kilometers"){if(!(e>=0))throw new Error("area must be a positive number");const o=t[r];if(!o)throw new Error("invalid original units");const i=t[n];if(!i)throw new Error("invalid final units");return e/o*i}function isNumber(e){return!isNaN(e)&&e!==null&&!Array.isArray(e)}function isObject(e){return e!==null&&typeof e==="object"&&!Array.isArray(e)}function validateBBox(e){if(!e)throw new Error("bbox is required");if(!Array.isArray(e))throw new Error("bbox must be an Array");if(e.length!==4&&e.length!==6)throw new Error("bbox must be an Array of 4 or 6 numbers");e.forEach((e=>{if(!isNumber(e))throw new Error("bbox must only contain numbers")}))}function validateId(e){if(!e)throw new Error("id is required");if(["string","number"].indexOf(typeof e)===-1)throw new Error("id must be a number or a string")}export{t as areaFactors,azimuthToBearing,bearingToAzimuth,convertArea,convertLength,degreesToRadians,e as earthRadius,r as factors,feature,featureCollection,geometry,geometryCollection,isNumber,isObject,lengthToDegrees,lengthToRadians,lineString,lineStrings,multiLineString,multiPoint,multiPolygon,point,points,polygon,polygons,radiansToDegrees,radiansToLength,round,validateBBox,validateId};

