// @turf/helpers@7.3.0 downloaded from https://ga.jspm.io/npm:@turf/helpers@7.3.0/dist/esm/index.js

var r=6371008.8;var e={centimeters:r*100,centimetres:r*100,degrees:360/(2*Math.PI),feet:r*3.28084,inches:r*39.37,kilometers:r/1e3,kilometres:r/1e3,meters:r,metres:r,miles:r/1609.344,millimeters:r*1e3,millimetres:r*1e3,nauticalmiles:r/1852,radians:1,yards:r*1.0936};var t={acres:247105e-9,centimeters:1e4,centimetres:1e4,feet:10.763910417,hectares:1e-4,inches:1550.003100006,kilometers:1e-6,kilometres:1e-6,meters:1,metres:1,miles:386e-9,nauticalmiles:2.9155334959812285e-7,millimeters:1e6,millimetres:1e6,yards:1.195990046};function n(r,e,t={}){const n={type:"Feature"};(t.id===0||t.id)&&(n.id=t.id);t.bbox&&(n.bbox=t.bbox);n.properties=e||{};n.geometry=r;return n}function o(r,e,t={}){switch(r){case"Point":return i(e).geometry;case"LineString":return c(e).geometry;case"Polygon":return u(e).geometry;case"MultiPoint":return h(e).geometry;case"MultiLineString":return f(e).geometry;case"MultiPolygon":return w(e).geometry;default:throw new Error(r+" is invalid")}}function i(r,e,t={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!k(r[0])||!k(r[1]))throw new Error("coordinates must contain numbers");const o={type:"Point",coordinates:r};return n(o,e,t)}function s(r,e,t={}){return m(r.map((r=>i(r,e))),t)}function u(r,e,t={}){for(const e of r){if(e.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(e[e.length-1].length!==e[0].length)throw new Error("First and last Position are not equivalent.");for(let r=0;r<e[e.length-1].length;r++)if(e[e.length-1][r]!==e[0][r])throw new Error("First and last Position are not equivalent.")}const o={type:"Polygon",coordinates:r};return n(o,e,t)}function a(r,e,t={}){return m(r.map((r=>u(r,e))),t)}function c(r,e,t={}){if(r.length<2)throw new Error("coordinates must be an array of two or more positions");const o={type:"LineString",coordinates:r};return n(o,e,t)}function l(r,e,t={}){return m(r.map((r=>c(r,e))),t)}function m(r,e={}){const t={type:"FeatureCollection"};e.id&&(t.id=e.id);e.bbox&&(t.bbox=e.bbox);t.features=r;return t}function f(r,e,t={}){const o={type:"MultiLineString",coordinates:r};return n(o,e,t)}function h(r,e,t={}){const o={type:"MultiPoint",coordinates:r};return n(o,e,t)}function w(r,e,t={}){const o={type:"MultiPolygon",coordinates:r};return n(o,e,t)}function b(r,e,t={}){const o={type:"GeometryCollection",geometries:r};return n(o,e,t)}function y(r,e=0){if(e&&!(e>=0))throw new Error("precision must be a positive number");const t=Math.pow(10,e||0);return Math.round(r*t)/t}function d(r,t="kilometers"){const n=e[t];if(!n)throw new Error(t+" units is invalid");return r*n}function g(r,t="kilometers"){const n=e[t];if(!n)throw new Error(t+" units is invalid");return r/n}function E(r,e){return v(g(r,e))}function p(r){let e=r%360;e<0&&(e+=360);return e}function P(r){r%=360;return r>180?r-360:r<-180?r+360:r}function v(r){const e=r%(2*Math.PI);return e*180/Math.PI}function x(r){const e=r%360;return e*Math.PI/180}function M(r,e="kilometers",t="kilometers"){if(!(r>=0))throw new Error("length must be a positive number");return d(g(r,e),t)}function A(r,e="meters",n="kilometers"){if(!(r>=0))throw new Error("area must be a positive number");const o=t[e];if(!o)throw new Error("invalid original units");const i=t[n];if(!i)throw new Error("invalid final units");return r/o*i}function k(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function q(r){return r!==null&&typeof r==="object"&&!Array.isArray(r)}function L(r){if(!r)throw new Error("bbox is required");if(!Array.isArray(r))throw new Error("bbox must be an Array");if(r.length!==4&&r.length!==6)throw new Error("bbox must be an Array of 4 or 6 numbers");r.forEach((r=>{if(!k(r))throw new Error("bbox must only contain numbers")}))}function F(r){if(!r)throw new Error("id is required");if(["string","number"].indexOf(typeof r)===-1)throw new Error("id must be a number or a string")}export{t as areaFactors,P as azimuthToBearing,p as bearingToAzimuth,A as convertArea,M as convertLength,x as degreesToRadians,r as earthRadius,e as factors,n as feature,m as featureCollection,o as geometry,b as geometryCollection,k as isNumber,q as isObject,E as lengthToDegrees,g as lengthToRadians,c as lineString,l as lineStrings,f as multiLineString,h as multiPoint,w as multiPolygon,i as point,s as points,u as polygon,a as polygons,v as radiansToDegrees,d as radiansToLength,y as round,L as validateBBox,F as validateId};

